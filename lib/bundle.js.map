{"version":3,"sources":["webpack:///webpack/bootstrap 3aa0ec7e8d7dfa02d1a2","webpack:///./lib/game.js","webpack:///./lib/painter.js","webpack:///./lib/paper.js","webpack:///./lib/grid.js","webpack:///./lib/enemies.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;;;AC7DA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;;AAEA;AACA,2EAAyB,eAAe;AACxC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,WAAW,YAAY,MAAM;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wBAAwB;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;AC9IA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;;;AAGA;;;;;;;;;;AC9LA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;;;;;;;;AChBD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;AChBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"./lib/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3aa0ec7e8d7dfa02d1a2","import Grid from \"./grid\";\nimport Painter from \"./painter\";\nimport Enemy from \"./enemies\";\n\nclass Game {\n  constructor(canvas, ctx) {\n    this.grid = [];\n    this.enemies = [];\n    this.painter = new Painter(canvas);\n\n    this.ctx = ctx;\n    this.canvas = canvas;\n    this.addGrid(canvas);\n\n    this.fps = 10; // ten frames per second\n    this.fpsInterval = 1000 / this.fps;\n    this.then = 0;\n    this.level = 1;\n    this.prevLevel = 1;\n    this.enemyCount = 4;\n\n    this.addEnemies(canvas);\n  }\n\n\n  addEnemies(canvas){\n    for (let i = 0; i < this.enemyCount; i++) {\n      this.enemies.push(new Enemy(canvas, this.painter));\n    }\n  }\n\n  addGrid(canvas) {\n    let grid = new Grid({canvas: canvas});\n    this.grid.push(grid);\n  }\n\n  allObjects(){\n    return [].concat(this.grid, this.painter, this.enemies);\n  }\n\n  draw(ctx) {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    this.allObjects().forEach((object) => {\n      this.drawScore(ctx);\n      this.painter.drawCurrentPos(ctx);\n      object.draw(this.ctx);\n    });\n\n  }\n\n  levelUp(canvas){\n    let score = this.painter.score();\n    if (score >= 0 && score < 10) {\n      this.level = 1;\n    } else if (score >= 10 && score < 30) {\n      this.level = 2;\n    } else if (score >= 30 && score < 60) {\n      this.level = 3;\n    } else if (score >= 60 && score < 80) {\n      this.level = 4;\n    } else if (score >= 80 && score < 100) {\n      this.level = 5;\n    }\n\n  }\n\n  start() {\n    requestAnimationFrame(this.animate.bind(this));\n  }\n\n\n  drawScore(ctx) {\n    let score = this.painter.score();\n    ctx.beginPath();\n    ctx.shadowBlur=3;\n    ctx.shadowColor=\"white\";\n    ctx.font = '24px BioRhyme';\n    ctx.fillText(`LVL: ${this.level} | SCORE: ${score}%`, 15, 585);\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  animate(){\n    const animationFrame = requestAnimationFrame(this.animate.bind(this));\n    this.levelUp();\n    if (this.prevLevel !== this.level) {\n      this.addEnemies(this.canvas);\n    }\n    this.prevLevel = this.level;\n\n    const now = Date.now();\n    const timeDelta = now - this.then;\n\n    if (timeDelta > this.fpsInterval) {\n      this.then = now - (timeDelta % this.fpsInterval);\n      this.painter.move();\n      this.draw(this.ctx);\n      this.enemies.forEach( (enemy) => enemy.move() );\n\n    }\n\n    if (this.painter.dead) {\n      this.ctx.beginPath();\n      this.ctx.shadowBlur=20;\n      this.ctx.shadowColor=\"white\";\n      this.ctx.fillStyle=\"black\";\n      this.ctx.font = '70px Bungee Shade';\n      this.ctx.fillText(`GAME OVER`, 200, 200);\n      this.ctx.closePath();\n      this.ctx.fill();\n\n      this.ctx.beginPath();\n      this.ctx.fillStyle=\"black\";\n      this.ctx.shadowBlur=0;\n      this.ctx.shadowColor=\"white\";\n      this.ctx.font = '40px BioRhyme';\n      this.ctx.fillText(`SCORE: ${this.painter.finalScore}%`, 280, 300);\n      this.ctx.fillText(`CLICK TO PLAY AGAIN!`, 180, 400);\n      this.ctx.closePath();\n      this.ctx.fill();\n      cancelAnimationFrame(animationFrame);\n    }\n    \n    if (this.painter.won) {\n      this.ctx.beginPath();\n      this.ctx.shadowBlur=20;\n      this.ctx.shadowColor=\"white\";\n      this.ctx.fillStyle=\"black\";\n      this.ctx.font = '70px Bungee Shade';\n      this.ctx.fillText(`YOU WON!`, 250, 300);\n      this.ctx.closePath();\n      this.ctx.fill();\n      cancelAnimationFrame(animationFrame);\n    }\n  }\n}\n\nGame.BG_COLOR = \"#000000\";\nGame.DIM_X = 900;\nGame.DIM_Y = 600;\n\nexport default Game;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/game.js\n// module id = 0\n// module chunks = 0","const Game = require(\"./game\");\n\nclass Painter {\n  constructor(canvas){\n    this.canvas = canvas;\n    this.width = this.canvas.width;\n    this.height = this.canvas.height;\n    this.cellSize = 15;\n    document.addEventListener('keydown', this.keyDown.bind(this), false);\n\n    this.keyPress = {\n      rightPressed: false,\n      leftPressed: false,\n      upPressed: false,\n      downPressed: false,\n    };\n\n    this.x = this.cellSize * Math.floor((Math.random() * (this.width / this.cellSize)));\n    this.y = this.cellSize * Math.floor((Math.random() * (this.height / this.cellSize)));\n    this.painted = [\n      [this.x, this.y],\n      [this.x + this.cellSize, this.y],\n      [this.x + this.cellSize, this.y + this.cellSize],\n      [this.x - this.cellSize, this.y + this.cellSize],\n      [this.x, this.y + this.cellSize],\n      [this.x - this.cellSize, this.y],\n      [this.x - this.cellSize, this.y - this.cellSize],\n      [this.x + this.cellSize, this.y - this.cellSize],\n      [this.x, this.y - this.cellSize]\n    ];\n    this.trail = [];\n    this.conquered = [];\n    this.dead = false;\n    this.finalScore = 0;\n    this.won = false;\n  }\n\n  keyDown(e) {\n\n    if (e.keyCode >= 37 && e.keyCode <= 40) {\n      this.keyPress.rightPressed = false;\n      this.keyPress.leftPressed = false;\n      this.keyPress.upPressed = false;\n      this.keyPress.downPressed = false;\n      switch(e.keyCode) {\n        case 37:\n        this.keyPress.leftPressed = true;\n        break;\n        case 38:\n        this.keyPress.downPressed = true;\n        break;\n        case 39:\n        this.keyPress.rightPressed = true;\n        break;\n        case 40:\n        this.keyPress.upPressed = true;\n        break;\n      }\n    }\n  }\n\n  move() {\n    if (this.keyPress.leftPressed) {\n      this.x -= this.cellSize;\n      if (!(this.x > 0 && this.x < this.width)) {\n        this.keyPress.leftPressed = false;\n      }\n\n    } else if (this.keyPress.downPressed) {\n      this.y -= this.cellSize;\n      if (!(this.y > 0 && this.y < this.height)) {\n        this.keyPress.downPressed = false;\n      }\n\n    } else if (this.keyPress.rightPressed) {\n      this.x += this.cellSize;\n      if (!(this.x > 0 && this.x < this.width - this.cellSize)) {\n        this.keyPress.rightPressed = false;\n      }\n\n    } else if (this.keyPress.upPressed) {\n      this.y += this.cellSize;\n      if (!(this.y > 0 && this.y < this.height - this.cellSize)) {\n        this.keyPress.upPressed = false;\n      }\n\n    }\n\n    if ((this.painted.find(el => el[0] === this.x\n      && el[1] === this.y) === undefined)\n      && (this.trail.find(el => el[0] === this.x\n        && el[1] === this.y) === undefined)) {\n          this.trail_safe = false;\n          this.trail.push([this.x, this.y]);\n        } else if (Boolean(this.trail.find(el => el[0] === this.x\n          && el[1] === this.y))) {\n            this.finalScore = this.score();\n            this.dead = true;\n          } else {\n            this.conquered = this.trail.slice();\n            this.painted = this.painted.concat(this.trail);\n            this.trail = [];\n            this.painted = this.sortCoords(this.painted);\n            this.painted = this.mapAllCoords(this.painted);\n            this.fillTrail();\n            // this.won();\n          }\n  }\n\n  drawCurrentPos(ctx) {\n    ctx.beginPath();\n    ctx.rect(this.x, this.y, this.cellSize, this.cellSize);\n    ctx.fillStyle=\"#4DA469\";\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  draw(ctx) {\n\n    ctx.beginPath();\n    this.trail.forEach( (coord, idx) => {\n      ctx.fillStyle=\"#86e0be\";\n      ctx.fillRect(coord[0], coord[1], this.cellSize, this.cellSize);\n    });\n    this.painted.forEach( coord => {\n      ctx.fillStyle=\"#4DA469\";\n      ctx.rect(coord[0], coord[1], this.cellSize, this.cellSize);\n    });\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  sortCoords(arr){\n    let sorted = arr.slice();\n\n    const funcSort = (x,  y) => {\n      return (x[0] - y[0] || x[1] - y[1]) ;\n    };\n\n    sorted = sorted.sort(funcSort);\n    return sorted;\n  }\n\n\n\n  mapAllCoords(sortedArr) {\n    let newArr = sortedArr.slice();\n    newArr.slice(0, sortedArr.length - 1).forEach( (coord, idx) => {\n      if ((newArr[idx][0] === newArr[idx + 1][0])\n        && (newArr[idx][1] !== (newArr[idx + 1][1]) - this.cellSize)) {\n          newArr.splice(\n            (idx + 1), 0, [newArr[idx][0], newArr[idx][1] + this.cellSize]\n          );\n        }\n    });\n    return newArr;\n  }\n\n  score(){\n    return (this.painted.length /\n      (this.height * this.width /\n        (this.cellSize * this.cellSize)) * 100).toFixed(2);\n  }\n\n  won(){\n    this.won = (this.score() >= 100);\n  }\n\n  trail(){\n    return this.trail;\n  }\n\n\n  fillTrail(){\n    if (this.conquered.length > 1){\n      let arr = this.conquered.slice();\n      let cornerPt = [arr[0][0], arr[arr.length-1][1]];\n      let missingPts = [];\n      let trailHash = {};\n      arr.forEach( (coord) => {\n        trailHash[parseInt(coord[0])] = trailHash[parseInt(coord[0])] || [];\n        trailHash[parseInt(coord[0])].push(coord[1]);\n      });\n\n    }\n\n  }\n}\n\n\nexport default Painter;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/painter.js\n// module id = 1\n// module chunks = 0","import Game from \"./game\";\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const canvasEl = document.getElementsByTagName(\"canvas\")[0];\n  canvasEl.width = Game.DIM_X;\n  canvasEl.height = Game.DIM_Y;\n\n  let game;\n  const ctx = canvasEl.getContext(\"2d\");\n  game = new Game(canvasEl, ctx);\n  canvasEl.addEventListener('click', () => {\n    if (game.painter.dead || game.painter.won) {\n      game = new Game(canvasEl, ctx);\n      game.start();\n    }\n  });\n  game.start();\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/paper.js\n// module id = 2\n// module chunks = 0","\nclass Grid {\n  constructor(options){\n    this.canvas = options.canvas;\n    this.cols = 40;\n    this.rows = 24;\n  }\n\n  draw(ctx) {\n    ctx.shadowBlur=0.5;\n    ctx.shadowColor=\"black\";\n    ctx.rect(0, 0, this.canvas.width, this.canvas.height);\n    ctx.stroke();\n  }\n}\n\nexport default Grid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/grid.js\n// module id = 3\n// module chunks = 0","import Game from \"./game\";\nimport Painter from \"./painter\";\n\nclass Enemy {\n  constructor(canvas, painter){\n    this.canvas = canvas;\n    this.width = this.canvas.width;\n    this.height = this.canvas.height;\n    this.cellSize = 15;\n\n    this.x = this.cellSize * Math.floor((Math.random() * (this.width / this.cellSize)));\n    this.y = this.cellSize * Math.floor((Math.random() * (this.height / this.cellSize)));\n\n    this.painter = painter;\n    this.kill = false;\n  }\n\n  move(){\n    let moves = [\n      [0, this.cellSize],\n      [this.cellSize, 0],\n      [0, -this.cellSize],\n      [-this.cellSize, 0]\n    ];\n\n    let nextMove = moves[Math.floor(Math.random() * moves.length)];\n\n    if (\n      (this.x + nextMove[0]) > 0 && ((this.x + nextMove[0]) < this.width)\n      &&\n      (this.y + nextMove[1]) > 0 && ((this.y + nextMove[1]) < this.height)\n    ) {\n      this.x += nextMove[0];\n      this.y += nextMove[1];\n      if (!(this.painter.trail.find(el => el[0] === this.x\n        && el[1] === this.y) === undefined) ||\n        (this.x === this.painter.x && this.y === this.painter.y)) {\n          this.painter.dead = true;\n          this.painter.finalScore = this.painter.score();\n        }\n    }\n  }\n\n  draw(ctx) {\n    ctx.beginPath();\n    ctx.shadowBlur=10;\n    ctx.shadowColor=\"black\";\n    ctx.rect(this.x, this.y, this.cellSize, this.cellSize);\n    ctx.fillStyle=\"black\";\n    ctx.closePath();\n    ctx.fill();\n  }\n}\nexport default Enemy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/enemies.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}