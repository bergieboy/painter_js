{"version":3,"sources":["webpack:///webpack/bootstrap 5952339fa5e0f1c0f436","webpack:///./lib/paper.js","webpack:///./lib/game.js","webpack:///./lib/painter.js","webpack:///./lib/grid.js","webpack:///./lib/enemies.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;;AC7DA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;ACVD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;;AAEA;AACA;;;AAGA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA;AACA,2EAAyB,eAAe;AACxC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;ACxEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,gBAAgB;AAC7C;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;;;;;;;;ACxLA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"./lib/bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5952339fa5e0f1c0f436","import Game from \"./game\";\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const canvasEl = document.getElementsByTagName(\"canvas\")[0];\n  canvasEl.width = Game.DIM_X;\n  canvasEl.height = Game.DIM_Y;\n\n  const ctx = canvasEl.getContext(\"2d\");\n  const game = new Game(canvasEl, ctx);\n  game.start();\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/paper.js\n// module id = 0\n// module chunks = 0","import Grid from \"./grid\";\nimport Painter from \"./painter\";\nimport Enemy from \"./enemies\";\n\nclass Game {\n  constructor(canvas, ctx) {\n    this.grid = [];\n    this.enemies = [];\n    this.painter = new Painter(canvas);\n\n    this.ctx = ctx;\n    this.canvas = canvas;\n    this.addGrid(canvas);\n\n    this.fps = 10; // ten frames per second\n    this.fpsInterval = 1000 / this.fps;\n    this.then = 0;\n\n    this.addEnemies(canvas);\n  }\n\n\n  addEnemies(canvas){\n    for (let i = 0; i < 10; i++) {\n      this.enemies.push(new Enemy(canvas, this.painter));\n    }\n  }\n\n  addGrid(canvas) {\n    let grid = new Grid({canvas: canvas});\n    console.log(canvas.width);\n    this.grid.push(grid);\n  }\n\n  allObjects(){\n    return [].concat(this.grid, this.painter, this.enemies);\n  }\n\n  draw(ctx) {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    this.allObjects().forEach((object) => {\n      object.draw(this.ctx);\n      this.painter.drawCurrentPos(ctx);\n    });\n\n  }\n\n  start() {\n    requestAnimationFrame(this.animate.bind(this));\n  }\n\n  animate(){\n    requestAnimationFrame(this.animate.bind(this));\n\n    const now = Date.now();\n    const timeDelta = now - this.then;\n\n    if (timeDelta > this.fpsInterval) {\n      this.then = now - (timeDelta % this.fpsInterval);\n      this.draw(this.ctx);\n      this.painter.move();\n      this.enemies.forEach( (enemy) => enemy.move() );\n\n    }\n  }\n}\n\nGame.BG_COLOR = \"#000000\";\nGame.DIM_X = 900;\nGame.DIM_Y = 600;\n\nexport default Game;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/game.js\n// module id = 1\n// module chunks = 0","const Game = require(\"./game\");\n\nclass Painter {\n  constructor(canvas){\n    this.canvas = canvas;\n    this.width = this.canvas.width;\n    this.height = this.canvas.height;\n    this.cellSize = 15;\n    document.addEventListener('keydown', this.keyDown.bind(this), false);\n\n    this.keyPress = {\n      rightPressed: false,\n      leftPressed: false,\n      upPressed: false,\n      downPressed: false,\n    };\n\n    this.x = this.cellSize * Math.floor((Math.random() * (this.width / this.cellSize)));\n    this.y = this.cellSize * Math.floor((Math.random() * (this.height / this.cellSize)));\n    this.painted = [\n      [this.x, this.y],\n      [this.x + this.cellSize, this.y],\n      [this.x + this.cellSize, this.y + this.cellSize],\n      [this.x - this.cellSize, this.y + this.cellSize],\n      [this.x, this.y + this.cellSize],\n      [this.x - this.cellSize, this.y],\n      [this.x - this.cellSize, this.y - this.cellSize],\n      [this.x + this.cellSize, this.y - this.cellSize],\n      [this.x, this.y - this.cellSize]\n    ];\n    this.trail = [];\n    this.dead = false;\n    this.finalScore = 0;\n  }\n\n  keyDown(e) {\n    switch(e.keyCode) {\n      case 37:\n        this.keyPress.rightPressed = false;\n        this.keyPress.leftPressed = true;\n        this.keyPress.upPressed = false;\n        this.keyPress.downPressed = false;\n        break;\n      case 38:\n        this.keyPress.rightPressed = false;\n        this.keyPress.leftPressed = false;\n        this.keyPress.upPressed = false;\n        this.keyPress.downPressed = true;\n        break;\n      case 39:\n        this.keyPress.rightPressed = true;\n        this.keyPress.leftPressed = false;\n        this.keyPress.upPressed = false;\n        this.keyPress.downPressed = false;\n        break;\n      case 40:\n        this.keyPress.rightPressed = false;\n        this.keyPress.leftPressed = false;\n        this.keyPress.upPressed = true;\n        this.keyPress.downPressed = false;\n        break;\n    }\n  }\n\n  move() {\n    if (this.keyPress.leftPressed) {\n      this.x -= this.cellSize;\n      if (!(this.x > 0 && this.x < this.width)) {\n        this.keyPress.leftPressed = false;\n      }\n\n    } else if (this.keyPress.downPressed) {\n      this.y -= this.cellSize;\n      if (!(this.y > 0 && this.y < this.height)) {\n        this.keyPress.downPressed = false;\n      }\n\n    } else if (this.keyPress.rightPressed) {\n      this.x += this.cellSize;\n      if (!(this.x > 0 && this.x < this.width)) {\n        this.keyPress.rightPressed = false;\n      }\n\n    } else if (this.keyPress.upPressed) {\n      this.y += this.cellSize;\n      if (!(this.y > 0 && this.y < this.height)) {\n        this.keyPress.upPressed = false;\n      }\n\n    }\n\n    if ((this.painted.find(el => el[0] === this.x\n      && el[1] === this.y) === undefined)\n      && (this.trail.find(el => el[0] === this.x\n        && el[1] === this.y) === undefined)) {\n          this.trail_safe = false;\n          this.trail.push([this.x, this.y]);\n        } else if (Boolean(this.trail.find(el => el[0] === this.x\n          && el[1] === this.y))) {\n            this.finalScore = this.score();\n            this.dead = true;\n          } else {\n            this.painted = this.painted.concat(this.trail);\n            this.trail = [];\n            this.painted = this.sortCoords(this.painted);\n            this.painted = this.mapAllCoords(this.painted);\n          }\n  }\n\n  drawCurrentPos(ctx) {\n    ctx.beginPath();\n    ctx.rect(this.x, this.y, this.cellSize, this.cellSize);\n    ctx.fillStyle=\"#4DA469\";\n    ctx.closePath();\n    ctx.fill();\n  }\n  draw(ctx) {\n    if (this.dead === true) {\n      ctx.beginPath();\n      ctx.fillStyle=\"black\";\n      ctx.font = '100px Bungee Shade';\n      ctx.fillText(`DEAD`, 280, 300);\n      ctx.closePath();\n      ctx.fill();\n\n      ctx.beginPath();\n      ctx.fillStyle=\"black\";\n      ctx.font = '40px BioRhyme';\n      ctx.fillText(`SCORE: ${this.finalScore}%`, 295, 400);\n      ctx.closePath();\n      ctx.fill();\n\n    } else {\n      ctx.beginPath();\n      this.trail.forEach( (coord, idx) => {\n        ctx.fillStyle=\"#86e0be\";\n        ctx.fillRect(coord[0], coord[1], this.cellSize, this.cellSize);\n      });\n      this.painted.forEach( coord => {\n        ctx.fillStyle=\"#4DA469\";\n        ctx.rect(coord[0], coord[1], this.cellSize, this.cellSize);\n      });\n      ctx.closePath();\n      ctx.fill();\n\n    }\n\n  }\n\n  sortCoords(arr){\n    let sorted = arr.slice();\n\n    const funcSort = (x,  y) => {\n      return (x[0] - y[0] || x[1] - y[1]) ;\n    };\n\n    sorted = sorted.sort(funcSort);\n    return sorted;\n  }\n\n  mapAllCoords(sortedArr) {\n    let newArr = sortedArr.slice();\n    newArr.slice(0, sortedArr.length - 1).forEach( (coord, idx) => {\n      if ((newArr[idx][0] === newArr[idx + 1][0])\n        && (newArr[idx][1] !== (newArr[idx + 1][1]) - this.cellSize)) {\n          newArr.splice(\n            (idx + 1), 0, [parseInt(newArr[idx][0]), parseInt(newArr[idx][1]) + this.cellSize]\n          );\n        }\n    });\n    return newArr;\n  }\n\n  score(){\n    return (this.painted.length /\n      (this.height * this.width /\n        (this.cellSize * this.cellSize)) * 100).toFixed(2);\n  }\n\n  trail(){\n    return this.trail;\n  }\n}\n\n\nexport default Painter;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/painter.js\n// module id = 3\n// module chunks = 0","\nclass Grid {\n  constructor(options){\n    this.canvas = options.canvas;\n    this.cols = 40;\n    this.rows = 24;\n  }\n\n  draw(ctx) {\n    ctx.shadowBlur=10;\n    ctx.shadowColor=\"black\";\n    ctx.rect(0, 0, this.canvas.width, this.canvas.height);\n    ctx.stroke();\n  }\n}\n\nexport default Grid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/grid.js\n// module id = 4\n// module chunks = 0","import Game from \"./game\";\nimport Painter from \"./painter\";\n\nclass Enemy {\n  constructor(canvas, painter){\n    this.canvas = canvas;\n    this.width = this.canvas.width;\n    this.height = this.canvas.height;\n    this.cellSize = 15;\n\n    this.x = this.cellSize * Math.floor((Math.random() * (this.width / this.cellSize)));\n    this.y = this.cellSize * Math.floor((Math.random() * (this.height / this.cellSize)));\n\n    this.painter = painter;\n    this.kill = false;\n  }\n\n  move(){\n    let moves = [\n      [0, this.cellSize],\n      [this.cellSize, 0],\n      [0, -this.cellSize],\n      [-this.cellSize, 0]\n    ];\n\n    let nextMove = moves[Math.floor(Math.random() * moves.length)];\n\n    if (\n      (this.x + nextMove[0]) > 0 && ((this.x + nextMove[0]) < this.width)\n      &&\n      (this.y + nextMove[1]) > 0 && ((this.y + nextMove[1]) < this.height)\n    ) {\n      this.x += nextMove[0];\n      this.y += nextMove[1];\n      if (!(this.painter.trail.find(el => el[0] === this.x\n        && el[1] === this.y) === undefined)) {\n          this.painter.dead = true;\n        }\n    }\n  }\n\n  draw(ctx) {\n    ctx.beginPath();\n    ctx.shadowBlur=5;\n    ctx.shadowColor=\"black\";\n    ctx.rect(this.x, this.y, this.cellSize, this.cellSize);\n    ctx.fillStyle=\"black\";\n    ctx.closePath();\n    ctx.fill();\n  }\n}\nexport default Enemy;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/enemies.js\n// module id = 6\n// module chunks = 0"],"sourceRoot":""}